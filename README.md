üåå AuraCode: Decentralized Virtual IDEAuraCode is a high-performance, decentralized development environment. It uses a "Virtual Node" architecture where a browser-based frontend communicates with local native bridges (C++, Python, Rust) via a standardized JSON-over-Base64 protocol.üèóÔ∏è System ArchitectureFrontend (Jekyll): Serves the UI and PWA shell.Logic Engine (work.js): Manages Multi-threaded execution and WASM runtimes (Python/SQL).Communication Layer (comm.js): Routes execution payloads to native nodes.Native Bridge (bridge.cpp): A high-speed socket server for C++ and Rust execution.Python Backend (backend.py): A Flask-based node for native Python/Subprocess execution.Orchestrator (launcher.py): Automated startup for all services.üì° 5-Digit Port StrategyTo avoid system conflicts and ensure stability, the following ports are strictly assigned:ServicePortProtocolJekyll Frontend54000HTTPPython Node55000JSON / RESTC++ Node56000JSON / SocketRust Node58000JSON / Socketüõ†Ô∏è File Registry & Rolesindex.html / style.css: The "Midnight" themed IDE workspace.work.js: Handles the Virtual File System (VFS) and worker-based code offloading.comm.js: The universal router. Transforms code into payload_schema.json format.bridge.cpp: The primary C++ executor. Must be compiled with -O3 and -lpthread.backend.py: The Python executor with UUID-based process isolation.launcher.py: The master script. Run python launcher.py to start the entire stack.package.json: Project metadata and dependency management.üöÄ Execution Workflow (For AI Context)User clicks "Run" in the UI.work.js captures the buffer and calculates a SHA-256 hash.If not cached, comm.js encodes the source to Base64.A JSON payload is sent to the 5-digit port corresponding to the selected language.The Native Node decodes, executes, and returns a JSON response:{"status": "success", "stdout": "...", "latency_ms": 150}The Terminal UI displays the output.üìù Required Changes / Copilot TODO ListInstruct GitHub Copilot to implement these specific logic bridges:Sync work.js with comm.js: Ensure the AuraRunner in work.js calls AuraComm.dispatch() for C++, Rust, and Python instead of the current local mocks.Monaco Editor Integration: Replace the textarea in index.html with a full Monaco Editor instance as referenced in package.json.Terminal Logic Expansion: Update AuraTerminal in work.js to handle wget, git, and npm by interacting with the vfs object in localStorage.Response Standardization: Ensure bridge.cpp and backend.py return identical JSON keys (stdout, exit_code, latency_ms) to prevent parsing errors in the frontend.Offline PWA Assets: Update sw.js to cache the Monaco Editor library and Pyodide tars for 100% offline usage.Build Command: npm start (Triggers launcher.py)
